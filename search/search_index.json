{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#wraptimer","title":"wraptimer","text":"<ul> <li>\ud83d\udcd6 Documentation</li> </ul> <p>An amazing alternative to Python's builtin <code>timeit</code> module that allows for high resolution timing of functions as well as in-depth line-by-line timing. It also exposes convenient classes to measure execution time for any arbitrary code.</p>"},{"location":"#sync-function-example","title":"Sync function example","text":"<p>Python<pre><code># imports\nimport time\nfrom wraptimer import TimeIt\n# Init\ntimeit = TimeIt()\n# decorate\n@timeit.byline\ndef test_by_line():\na = 10\nb = 20\ntime.sleep(0.8)\nc = a + b\nreturn [a, b, c]\n# run\ntest_by_line()\n</code></pre> </p>"},{"location":"#async-function-example","title":"Async function example","text":"<p>Python<pre><code># Imports\nimport asyncio\nfrom wraptimer import TimeIt\n# Init\ntimeit = TimeIt()\n# decorate\n@timeit.byline\nasync def test_by_line_async():\na = 10\nb = 20\nawait asyncio.sleep(1.25)\nreturn [a, b]\n# run\nasyncio.run(test_by_line_async()) \n</code></pre> </p>"},{"location":"#dont-need-line-by-line-tracing","title":"Don't need Line-by-line tracing?","text":"<p>Use <code>@timeit.func</code> if you do not want to print line-by-line durations.</p> Python<pre><code>...\n@timeit.func\nasync def test_by_line_async():\na = 10\nb = 20\nawait asyncio.sleep(1.25)\nreturn [a, b]\n</code></pre> <p> </p>"},{"location":"#read-the-documentation","title":"Read the documentation","text":"<p>For more about wraptimer, Read The Documentation</p>"},{"location":"timeit/","title":"Timeit","text":""},{"location":"timeit/#timer-module","title":"Timer Module","text":""},{"location":"timeit/#wraptimer.timeit","title":"wraptimer.timeit","text":"<p>Copyright (c) 2023 Anthony Mugendi</p> <p>This software is released under the MIT License. https://opensource.org/licenses/MIT</p>"},{"location":"timeit/#wraptimer.timeit.TimeIt","title":"TimeIt","text":"Source code in <code>wraptimer/timeit.py</code> Python<pre><code>class TimeIt:\ndef __init__(self, verbose: bool = True, show_args: bool = False):\nself.verbose = verbose\nself.show_args = show_args\ndef byline(self, func):\n\"\"\"Function decorator to print duration taken to run decorated function\n        line by line.\n        Works for both sync and async functions.\n        Example:\n        ```python\n        from wraptimer import TimeIt\n        # init\n        timeit = TimeIt(verbose=True, show_args=True)\n        # decorate\n        @timeit.byline\n        def func_to_time():\n            timer.sleep(1)\n        ```\n        \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\ndebug_context = DebugContext(\nname=func.__name__, verbose=self.verbose, func=func\n)\nwith debug_context:\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# print(debug_context.traced)\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"bottom\", \"mid\"],\n)\nreturn result\nelse:\nreturn (\nresult,\ndebug_context.traced,\nlog(\nfunc,\nt,\nargs,\nkwargs,\nself.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\ndef func(self, func: callable) -&gt; None:\n\"\"\"Function decorator to print duration taken to run decorated function.\n        Works for both sync and async functions.\n        Example:\n        ```python\n        from wraptimer import TimeIt\n        # init\n        timeit = TimeIt(verbose=True, show_args=True)\n        # decorate\n        @timeit.func\n        def func_to_time():\n            timer.sleep(1)\n        ```\n        \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# if verbose, log\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"top\", \"bottom\"],\n)\nreturn result\nelse:\nreturn (\nresult,\nlog(\nwht=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\n</code></pre>"},{"location":"timeit/#wraptimer.timeit.TimeIt.byline","title":"byline","text":"Python<pre><code>byline(func)\n</code></pre> <p>Function decorator to print duration taken to run decorated function line by line. Works for both sync and async functions.</p> <p>Example:</p> Python<pre><code>from wraptimer import TimeIt\n# init\ntimeit = TimeIt(verbose=True, show_args=True)\n# decorate\n@timeit.byline\ndef func_to_time():\ntimer.sleep(1)\n</code></pre> Source code in <code>wraptimer/timeit.py</code> Python<pre><code>def byline(self, func):\n\"\"\"Function decorator to print duration taken to run decorated function\n    line by line.\n    Works for both sync and async functions.\n    Example:\n    ```python\n    from wraptimer import TimeIt\n    # init\n    timeit = TimeIt(verbose=True, show_args=True)\n    # decorate\n    @timeit.byline\n    def func_to_time():\n        timer.sleep(1)\n    ```\n    \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\ndebug_context = DebugContext(\nname=func.__name__, verbose=self.verbose, func=func\n)\nwith debug_context:\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# print(debug_context.traced)\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"bottom\", \"mid\"],\n)\nreturn result\nelse:\nreturn (\nresult,\ndebug_context.traced,\nlog(\nfunc,\nt,\nargs,\nkwargs,\nself.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\n</code></pre>"},{"location":"timeit/#wraptimer.timeit.TimeIt.func","title":"func","text":"Python<pre><code>func(func: callable) -&gt; None\n</code></pre> <p>Function decorator to print duration taken to run decorated function. Works for both sync and async functions.</p> <p>Example:</p> Python<pre><code>from wraptimer import TimeIt\n# init\ntimeit = TimeIt(verbose=True, show_args=True)\n# decorate\n@timeit.func\ndef func_to_time():\ntimer.sleep(1)\n</code></pre> Source code in <code>wraptimer/timeit.py</code> Python<pre><code>def func(self, func: callable) -&gt; None:\n\"\"\"Function decorator to print duration taken to run decorated function.\n    Works for both sync and async functions.\n    Example:\n    ```python\n    from wraptimer import TimeIt\n    # init\n    timeit = TimeIt(verbose=True, show_args=True)\n    # decorate\n    @timeit.func\n    def func_to_time():\n        timer.sleep(1)\n    ```\n    \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# if verbose, log\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"top\", \"bottom\"],\n)\nreturn result\nelse:\nreturn (\nresult,\nlog(\nwht=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\n</code></pre>"},{"location":"timer/","title":"Timer","text":""},{"location":"timer/#timer-module","title":"Timer Module","text":""},{"location":"timer/#wraptimer.timer","title":"wraptimer.timer","text":"<p>Copyright (c) 2023 Anthony Mugendi</p> <p>This software is released under the MIT License. https://opensource.org/licenses/MIT</p>"},{"location":"timer/#wraptimer.timer.Timer","title":"Timer","text":""},{"location":"timer/#wraptimer.timer.Timer--timer-class","title":"Timer Class.","text":"<p>Timer type can only take the following string values:</p> <ul> <li><code>performance</code>:     the most precise clock in the system.</li> <li><code>process</code>:     measures the CPU time, meaning sleep time is not measured.</li> <li><code>long_running</code>:     it is an increasing clock that do not change when     the date and or time of the machine is changed.</li> </ul>"},{"location":"timer/#wraptimer.timer.Timer--example","title":"Example","text":"Python<pre><code>import time\nfrom wraptimer import Timer\n# initialize\nt = Timer(timer_type=\"performance\")\n# start timer\nt.start()\n# some long running code\ntime.sleep(1)\n# stop timer\nt.stop()\n# get duration taken to run\nprint('took', t.time_string)\n</code></pre> Source code in <code>wraptimer/timer.py</code> Python<pre><code>class Timer:\n\"\"\"\n    # Timer Class.\n    Timer type can only take the following string values:\n    - `performance`:\n        the most precise clock in the system.\n    - `process`:\n        measures the CPU time, meaning sleep time is not measured.\n    - `long_running`:\n        it is an increasing clock that do not change when\n        the date and or time of the machine is changed.\n    # Example\n    ```python\n    import time\n    from wraptimer import Timer\n    # initialize\n    t = Timer(timer_type=\"performance\")\n    # start timer\n    t.start()\n    # some long running code\n    time.sleep(1)\n    # stop timer\n    t.stop()\n    # get duration taken to run\n    print('took', t.time_string)\n    ```\n    \"\"\"\n_counter_start: Optional[int] = None\n_counter_stop: Optional[int] = None\n_is_started = False\ndef __init__(\nself,\ntimer_type: Literal[\"performance\", \"process\", \"long_running\"] = \"performance\",\ndisable_garbage_collect: bool = True,\n) -&gt; None:\nself.timer_type = timer_type\nself.disable_garbage_collect = disable_garbage_collect\ndef start(self) -&gt; None:\n\"\"\"Starts the timer .\"\"\"\nif self._is_started:\nreturn\nif self.disable_garbage_collect:\ngc.disable()\nself._counter_start = self.__get_counter()\nself._is_started = True\ndef stop(self) -&gt; None:\n\"\"\"Stop the timer .\"\"\"\nself._counter_stop = self.__get_counter()\nif self.disable_garbage_collect:\ngc.enable()\nself._is_started = False\n@property\ndef time_nanosec(self) -&gt; float:\n\"\"\"Return the number of nanoseconds taken from start() to stop().\n        Returns:\n            float: nanoseconds as a float\n        \"\"\"\nself.__valid_start_stop()\nreturn self._counter_stop - self._counter_start  # type: ignore\n@property\ndef time_sec(self) -&gt; float:\n\"\"\"Return the number of seconds taken from start() to stop().\n        Returns:\n            float: seconds as a float\n        \"\"\"\nreturn self.time_nanosec / 1e9\n@property\ndef time_millisec(self) -&gt; float:\n\"\"\"Return the number of milliseconds taken from start() to stop().\n        Returns:\n            float: milliseconds as a float\n        \"\"\"\nreturn self.time_nanosec / 1e6\n@property\ndef time_microsec(self) -&gt; float:\n\"\"\"Return the number of microseconds taken from start() to stop().\n        Returns:\n            float: microseconds as a float\n        \"\"\"\nreturn self.time_nanosec / 1e3\n@property\ndef time_units(self) -&gt; dict:\n\"\"\"Return a dictionary of time taken from start() to stop().\n        Returns:\n            float: nanoseconds as a float\n        \"\"\"\ntimers = [\n{\"units\": \"s\", \"value\": self.time_sec},\n{\"units\": \"ms\", \"value\": self.time_millisec},\n{\"units\": \"\u03bcs\", \"value\": self.time_microsec},\n{\"units\": \"ns\", \"value\": self.time_nanosec},\n]\n# print(timers)\nfiltered = list(filter(lambda t: t[\"value\"] &gt; 1, timers))\nreturn filtered[0]\n@property\ndef time_string(self) -&gt; str:\n\"\"\"Return human readable duration taken from start() to stop().\n        Returns:\n            str: human readable duration\n        \"\"\"\ntook = self.time_units\nreturn \"{} {}\".format(took[\"value\"], took[\"units\"])\ndef __get_counter(self) -&gt; int:\ncounter: int\nif self.timer_type == \"performance\":\ncounter = time.perf_counter_ns()\nelif self.timer_type == \"process\":\ncounter = time.process_time_ns()\nelif self.timer_type == \"long_running\":\ncounter = time.monotonic_ns()\nreturn counter\ndef __valid_start_stop(self) -&gt; Optional[NoReturn]:\nif self._counter_start is None:\nraise ValueError(\"Timer has not been started.\")\nif self._counter_stop is None:\nraise ValueError(\"Timer has not been stopped.\")\nreturn None\n</code></pre>"},{"location":"timer/#wraptimer.timer.Timer.time_microsec","title":"time_microsec  <code>property</code>","text":"Python<pre><code>time_microsec: float\n</code></pre> <p>Return the number of microseconds taken from start() to stop(). Returns:     float: microseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_millisec","title":"time_millisec  <code>property</code>","text":"Python<pre><code>time_millisec: float\n</code></pre> <p>Return the number of milliseconds taken from start() to stop(). Returns:     float: milliseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_nanosec","title":"time_nanosec  <code>property</code>","text":"Python<pre><code>time_nanosec: float\n</code></pre> <p>Return the number of nanoseconds taken from start() to stop(). Returns:     float: nanoseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_sec","title":"time_sec  <code>property</code>","text":"Python<pre><code>time_sec: float\n</code></pre> <p>Return the number of seconds taken from start() to stop(). Returns:     float: seconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_string","title":"time_string  <code>property</code>","text":"Python<pre><code>time_string: str\n</code></pre> <p>Return human readable duration taken from start() to stop(). Returns:     str: human readable duration</p>"},{"location":"timer/#wraptimer.timer.Timer.time_units","title":"time_units  <code>property</code>","text":"Python<pre><code>time_units: dict\n</code></pre> <p>Return a dictionary of time taken from start() to stop(). Returns:     float: nanoseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.start","title":"start","text":"Python<pre><code>start() -&gt; None\n</code></pre> <p>Starts the timer .</p> Source code in <code>wraptimer/timer.py</code> Python<pre><code>def start(self) -&gt; None:\n\"\"\"Starts the timer .\"\"\"\nif self._is_started:\nreturn\nif self.disable_garbage_collect:\ngc.disable()\nself._counter_start = self.__get_counter()\nself._is_started = True\n</code></pre>"},{"location":"timer/#wraptimer.timer.Timer.stop","title":"stop","text":"Python<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the timer .</p> Source code in <code>wraptimer/timer.py</code> Python<pre><code>def stop(self) -&gt; None:\n\"\"\"Stop the timer .\"\"\"\nself._counter_stop = self.__get_counter()\nif self.disable_garbage_collect:\ngc.enable()\nself._is_started = False\n</code></pre>"}]}