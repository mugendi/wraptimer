{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#wraptimer","title":"wraptimer","text":"<ul> <li>\ud83d\udcd6 Documentation</li> <li>\ud83d\udcd6 Documentation</li> </ul> <p>An amazing alternative to Python's builtin <code>timeit</code> module that allows for high resolution timing of functions as well as in-depth line-by-line timing. It also exposes convenient classes to measure execution time for any arbitrary code.</p> <p> </p>"},{"location":"#sync-function-example","title":"Sync function example","text":"<p><pre><code># imports\nimport time\nfrom wraptimer import TimeIt\n# Init\ntimeit = TimeIt()\n# decorate\n@timeit.byline\ndef test_by_line():\na = 10\nb = 20\ntime.sleep(0.8)\nc = a + b\nreturn [a, b, c]\n# run\ntest_by_line()\n</code></pre> </p>"},{"location":"#async-function-example","title":"Async function example","text":"<p><pre><code># Imports\nimport asyncio\nfrom wraptimer import TimeIt\n# Init\ntimeit = TimeIt()\n# decorate\n@timeit.byline\nasync def test_by_line_async():\na = 10\nb = 20\nawait asyncio.sleep(1.25)\nreturn [a, b]\n# run\nasyncio.run(test_by_line_async()) \n</code></pre> </p>"},{"location":"#dont-need-line-by-line-tracing","title":"Don't need Line-by-line tracing?","text":"<p>Use <code>@timeit.func</code> if you do not want to print line-by-line durations.</p> <pre><code>...\n@timeit.func\nasync def test_by_line_async():\na = 10\nb = 20\nawait asyncio.sleep(1.25)\nreturn [a, b]\n</code></pre> <p> </p>"},{"location":"#read-the-documentation","title":"Read the documentation","text":"<p>For more about wraptimer, Read The Documentation</p>"},{"location":"timeit/","title":"Timeit","text":""},{"location":"timeit/#timer-module","title":"Timer Module","text":""},{"location":"timeit/#wraptimer.timeit","title":"wraptimer.timeit","text":"<p>Copyright (c) 2023 Anthony Mugendi</p> <p>This software is released under the MIT License. https://opensource.org/licenses/MIT</p>"},{"location":"timeit/#wraptimer.timeit.TimeIt","title":"TimeIt","text":""},{"location":"timeit/#wraptimer.timeit.TimeIt--timeit-class","title":"Timeit Class","text":"<p>This class exposes two decorators <code>@byline</code> and <code>@func</code> which work perfectly with both synchronous and asynchronous functions.</p>"},{"location":"timeit/#wraptimer.timeit.TimeIt--args","title":"Args:","text":"<ul> <li> <p><code>verbose</code> bool : Defaults to <code>True</code>. If True, then decorators will print execution time to console. If false then the execution time data is added to the function response so that it return a tuple.</p> <p>Example: <pre><code># init\nimport pprint\ntimeit_non_verbose = TimeIt(verbose=False)\n# decorate\n@timeit_non_verbose.byline\ndef test_non_verbose(v=1):\ntime.sleep(1.5)\nx = v * 50\nreturn x\nresp = test_non_verbose(22)\npprint.pprint(resp)\n</code></pre> This will output: <pre><code>(1100,\n    [{'LINE': 75, 'SYNC FUNC': 'test_non_verbose', 'TOOK': '1.501589155 s'},\n    {'LINE': 76, 'SYNC FUNC': 'test_non_verbose', 'TOOK': '29.476 \u03bcs'}],\n    [' TOOK: 1.501719173 s'])\n</code></pre> Where:</p> <ol> <li>The first value 1100 is the si the <code>test_non_verbose()</code> return value i.e 22*50</li> <li>The second tuple value is a list of all execution times in this case by line execution times and total execution time</li> </ol> <p>Note</p> <p>Setting <code>verbose</code> to <code>False</code> is useful in cases where you want to measure execution time and instead of printing, use the values in other ways, such as saving the data to a timeseries database for future reporting on code execution.</p> </li> <li> <p><code>show_args</code> bool : Defaults to <code>False</code>. When set to <code>True</code>, arguments passed to the decorated function are printed.</p> <p>Example: <pre><code># init\ntimeit_non_verbose = TimeIt(show_args=True)\n# decorate\n@timeit_non_verbose.byline\ndef test_non_verbose(v=1):\ntime.sleep(1.5)\nx = v * 50\nreturn x\ntest_non_verbose(22)\n</code></pre> Logs:  <pre><code>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 [ SYNC FUNC: test_non_verbose ] \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nLINE: 89, TOOK: 1.500271156 s\nLINE: 90, TOOK: 320.156 \u03bcs\n------------------------------------------------------------------------------\nARGS: (22,)\nKWARGS: {}\nTOOK: 1.50086468 s\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n</code></pre></p> <p>Note</p> <p>Values of <code>ARGS: (22,)</code> and <code>KWARGS: {}</code> are printed.</p> <p>This setting is important foe when you are measuring execution times of the same functions but passing varying arguments. That way you c`an see how each argument affects execution time.</p> </li> </ul> Source code in <code>wraptimer/timeit.py</code> <pre><code>class TimeIt:\n\"\"\"# Timeit Class\n    This class exposes two decorators `@byline` and `@func`\n    which work perfectly with both synchronous and asynchronous\n    functions.\n    ## Args:\n    - `verbose` bool : Defaults to `True`.\n    If True, then decorators will print execution time\n    to console. If false then the execution time data is added to\n    the function response so that it return a tuple.\n        **Example:**\n        ```python\n        # init\n        import pprint\n        timeit_non_verbose = TimeIt(verbose=False)\n        # decorate\n        @timeit_non_verbose.byline\n        def test_non_verbose(v=1):\n            time.sleep(1.5)\n            x = v * 50\n            return x\n        resp = test_non_verbose(22)\n        pprint.pprint(resp)\n        ```\n        This will output:\n        ```txt\n        (1100,\n            [{'LINE': 75, 'SYNC FUNC': 'test_non_verbose', 'TOOK': '1.501589155 s'},\n            {'LINE': 76, 'SYNC FUNC': 'test_non_verbose', 'TOOK': '29.476 \u03bcs'}],\n            [' TOOK: 1.501719173 s'])\n        ```\n        Where:\n        1. The first value **1100** is the si the `test_non_verbose()`\n        return value i.e **22*50**\n        2. The second tuple value is a list of all execution times\n        in this case *by line* execution times and *total execution time*\n        !!! note\n            Setting `verbose` to `False` is useful in cases where you want\n            to measure execution time and instead of printing, use the values\n            in other ways, such as saving the data to a timeseries database\n            for future reporting on code execution.\n    - `show_args` bool : Defaults to `False`. When set to `True`, arguments\n    passed to the decorated function are printed.\n        **Example:**\n        ```python\n        # init\n        timeit_non_verbose = TimeIt(show_args=True)\n        # decorate\n        @timeit_non_verbose.byline\n        def test_non_verbose(v=1):\n            time.sleep(1.5)\n            x = v * 50\n            return x\n        test_non_verbose(22)\n        ```\n        Logs:\n        ![](images/)\n        ```txt\n        \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 [ SYNC FUNC: test_non_verbose ] \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n        LINE: 89, TOOK: 1.500271156 s\n        LINE: 90, TOOK: 320.156 \u03bcs\n        ------------------------------------------------------------------------------\n        ARGS: (22,)\n        KWARGS: {}\n        TOOK: 1.50086468 s\n        \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n        ```\n        !!! note\n            Values of `ARGS: (22,)` and `KWARGS: {}` are printed.\n            This setting is important foe when you are measuring execution\n            times of the same functions but passing varying arguments.\n            That way you c`an see how each argument affects execution time.\n    \"\"\"\ndef __init__(self, verbose: bool = True, show_args: bool = False):\nself.verbose = verbose\nself.show_args = show_args\ndef byline(self, func):\n\"\"\"Function decorator to print duration taken to run decorated function\n        line by line.\n        Works for both sync and async functions.\n        Example:\n        ```python\n        from wraptimer import TimeIt\n        # init\n        timeit = TimeIt(verbose=True, show_args=True)\n        # decorate\n        @timeit.byline\n        def func_to_time():\n            timer.sleep(1)\n        ```\n        \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\ndebug_context = DebugContext(\nname=func.__name__, verbose=self.verbose, func=func\n)\nwith debug_context:\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# print(debug_context.traced)\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"bottom\", \"mid\"],\n)\nreturn result\nelse:\nreturn (\nresult,\ndebug_context.traced,\nlog(\nfunc,\nt,\nargs,\nkwargs,\nself.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\ndef func(self, func: callable) -&gt; None:\n\"\"\"Function decorator to print duration taken to run decorated function.\n        Works for both sync and async functions.\n        Example:\n        ```python\n        from wraptimer import TimeIt\n        # init\n        timeit = TimeIt(verbose=True, show_args=True)\n        # decorate\n        @timeit.func\n        def func_to_time():\n            timer.sleep(1)\n        ```\n        \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# if verbose, log\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"top\", \"bottom\"],\n)\nreturn result\nelse:\nreturn (\nresult,\nlog(\nwht=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\n</code></pre>"},{"location":"timeit/#wraptimer.timeit.TimeIt.byline","title":"byline","text":"<pre><code>byline(func)\n</code></pre> <p>Function decorator to print duration taken to run decorated function line by line. Works for both sync and async functions.</p> <p>Example:</p> <pre><code>from wraptimer import TimeIt\n# init\ntimeit = TimeIt(verbose=True, show_args=True)\n# decorate\n@timeit.byline\ndef func_to_time():\ntimer.sleep(1)\n</code></pre> Source code in <code>wraptimer/timeit.py</code> <pre><code>def byline(self, func):\n\"\"\"Function decorator to print duration taken to run decorated function\n    line by line.\n    Works for both sync and async functions.\n    Example:\n    ```python\n    from wraptimer import TimeIt\n    # init\n    timeit = TimeIt(verbose=True, show_args=True)\n    # decorate\n    @timeit.byline\n    def func_to_time():\n        timer.sleep(1)\n    ```\n    \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\ndebug_context = DebugContext(\nname=func.__name__, verbose=self.verbose, func=func\n)\nwith debug_context:\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# print(debug_context.traced)\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"bottom\", \"mid\"],\n)\nreturn result\nelse:\nreturn (\nresult,\ndebug_context.traced,\nlog(\nfunc,\nt,\nargs,\nkwargs,\nself.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\n</code></pre>"},{"location":"timeit/#wraptimer.timeit.TimeIt.func","title":"func","text":"<pre><code>func(func: callable) -&gt; None\n</code></pre> <p>Function decorator to print duration taken to run decorated function. Works for both sync and async functions.</p> <p>Example:</p> <pre><code>from wraptimer import TimeIt\n# init\ntimeit = TimeIt(verbose=True, show_args=True)\n# decorate\n@timeit.func\ndef func_to_time():\ntimer.sleep(1)\n</code></pre> Source code in <code>wraptimer/timeit.py</code> <pre><code>def func(self, func: callable) -&gt; None:\n\"\"\"Function decorator to print duration taken to run decorated function.\n    Works for both sync and async functions.\n    Example:\n    ```python\n    from wraptimer import TimeIt\n    # init\n    timeit = TimeIt(verbose=True, show_args=True)\n    # decorate\n    @timeit.func\n    def func_to_time():\n        timer.sleep(1)\n    ```\n    \"\"\"\n@wraps(func)\nasync def wrapper(*args, **kwargs):\nt = Timer()\nt.start()\n# run with await if async function\nif asyncio.iscoroutinefunction(func):\nresult = await func(*args, **kwargs)\nelse:\nresult = func(*args, **kwargs)\nt.stop()\n# if verbose, log\nif self.verbose:\nlog(\nwhat=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\ndraw_sep=[\"top\", \"bottom\"],\n)\nreturn result\nelse:\nreturn (\nresult,\nlog(\nwht=func,\nt=t,\nargs=args,\nkwargs=kwargs,\nshow_args=self.show_args,\nreturn_trace=True,\n),\n)\ndef run(*args, **kwargs):\nreturn asyncio.run(wrapper(*args, **kwargs))\nasync def async_run(*args, **kwargs):\nreturn await wrapper(*args, **kwargs)\nreturn async_run if asyncio.iscoroutinefunction(func) else run\n</code></pre>"},{"location":"timer/","title":"Timer","text":""},{"location":"timer/#timer-module","title":"Timer Module","text":""},{"location":"timer/#wraptimer.timer","title":"wraptimer.timer","text":"<p>Copyright (c) 2023 Anthony Mugendi</p> <p>This software is released under the MIT License. https://opensource.org/licenses/MIT</p>"},{"location":"timer/#wraptimer.timer.Timer","title":"Timer","text":""},{"location":"timer/#wraptimer.timer.Timer--timer-class","title":"Timer Class.","text":"<p>This class helps you to create high precision timers to measure any code processes.</p>"},{"location":"timer/#wraptimer.timer.Timer--args","title":"Args:","text":"<ul> <li> <p><code>timer_type</code> (Literal[, optional):     Determines what clock is used.     Defaults to \"performance\".     <code>timer_type</code> can only take the following string values:</p> <ol> <li>\"performance\": the most precise clock in the system.</li> <li>\"process\": measures the CPU time, meaning sleep time is not measured.</li> <li>\"long_running\": it is an increasing clock that do not change when     the date and or time of the machine is changed.</li> </ol> </li> <li> <p><code>disable_garbage_collect</code> (bool, optional):     Determines if garbage collection is disabled.</p> <p>Defaults to True.</p> <p>Note</p> <p>With high precision timers, it is best to disable garbage collection so that it does not affect how long the code actually takes to run.</p> </li> </ul>"},{"location":"timer/#wraptimer.timer.Timer--example-usage","title":"Example Usage","text":"<pre><code>import time\nfrom wraptimer import Timer\n# initialize\nt = Timer(timer_type=\"performance\")\n# start timer\nt.start()\n# some long running code\ntime.sleep(1)\n# stop timer\nt.stop()\n# get duration taken to run\nprint('took', t.time_string)\n</code></pre> Source code in <code>wraptimer/timer.py</code> <pre><code>class Timer:\n\"\"\"\n    # Timer Class.\n    This class helps you to create high precision timers to measure any code processes.\n    ## Args:\n    - `timer_type` (Literal[, optional):\n        Determines what clock is used.\n        Defaults to \"performance\".\n        `timer_type` can only take the following string values:\n        1. \"performance\": the most precise clock in the system.\n        2. \"process\": measures the CPU time, meaning sleep time is not measured.\n        3. \"long_running\": it is an increasing clock that do not change when\n            the date and or time of the machine is changed.\n    - `disable_garbage_collect` (bool, optional):\n        Determines if garbage collection is disabled.\n        Defaults to True.\n        !!! Note\n            With high precision timers, it is best to disable garbage collection\n            so that it does not affect how long the code actually takes to run.\n    # Example Usage\n    ```python\n    import time\n    from wraptimer import Timer\n    # initialize\n    t = Timer(timer_type=\"performance\")\n    # start timer\n    t.start()\n    # some long running code\n    time.sleep(1)\n    # stop timer\n    t.stop()\n    # get duration taken to run\n    print('took', t.time_string)\n    ```\n    \"\"\"\n_counter_start: Optional[int] = None\n_counter_stop: Optional[int] = None\n_is_started = False\ndef __init__(\nself,\ntimer_type: Literal[\"performance\", \"process\", \"long_running\"] = \"performance\",\ndisable_garbage_collect: bool = True,\n) -&gt; None:\nself.timer_type = timer_type\nself.disable_garbage_collect = disable_garbage_collect\ndef start(self) -&gt; None:\n\"\"\"Starts the timer .\"\"\"\nif self._is_started:\nreturn\nif self.disable_garbage_collect:\ngc.disable()\nself._counter_start = self.__get_counter()\nself._is_started = True\ndef stop(self) -&gt; None:\n\"\"\"Stops the timer .\"\"\"\nself._counter_stop = self.__get_counter()\nif self.disable_garbage_collect:\ngc.enable()\nself._is_started = False\n@property\ndef time_nanosec(self) -&gt; float:\n\"\"\"Get number of nanoseconds taken from start() to stop().\n        Returns:\n            `float`: nanoseconds as a float\n        \"\"\"\nself.__valid_start_stop()\nreturn self._counter_stop - self._counter_start  # type: ignore\n@property\ndef time_sec(self) -&gt; float:\n\"\"\"Get number of seconds taken from start() to stop().\n        Returns:\n            `float`: seconds as a float\n        \"\"\"\nreturn self.time_nanosec / 1e9\n@property\ndef time_millisec(self) -&gt; float:\n\"\"\"Get number of milliseconds taken from start() to stop().\n        Returns:\n            `float`: milliseconds as a float\n        \"\"\"\nreturn self.time_nanosec / 1e6\n@property\ndef time_microsec(self) -&gt; float:\n\"\"\"Get number of microseconds taken from start() to stop().\n        Returns:\n            `float`: microseconds as a float\n        \"\"\"\nreturn self.time_nanosec / 1e3\n@property\ndef time_units(self) -&gt; dict:\n\"\"\"Get dictionary of time taken from start() to stop().\n        Returns:\n            `float`: nanoseconds as a float\n        \"\"\"\ntimers = [\n{\"units\": \"s\", \"value\": self.time_sec},\n{\"units\": \"ms\", \"value\": self.time_millisec},\n{\"units\": \"\u03bcs\", \"value\": self.time_microsec},\n{\"units\": \"ns\", \"value\": self.time_nanosec},\n]\n# print(timers)\nfiltered = list(filter(lambda t: t[\"value\"] &gt; 1, timers))\nreturn filtered[0]\n@property\ndef time_string(self) -&gt; str:\n\"\"\"Get human readable duration taken from start() to stop().\n        Returns:\n            `str`: human readable duration\n        \"\"\"\ntook = self.time_units\nreturn \"{} {}\".format(took[\"value\"], took[\"units\"])\ndef __get_counter(self) -&gt; int:\ncounter: int\nif self.timer_type == \"performance\":\ncounter = time.perf_counter_ns()\nelif self.timer_type == \"process\":\ncounter = time.process_time_ns()\nelif self.timer_type == \"long_running\":\ncounter = time.monotonic_ns()\nreturn counter\ndef __valid_start_stop(self) -&gt; Optional[NoReturn]:\nif self._counter_start is None:\nraise ValueError(\"Timer has not been started.\")\nif self._counter_stop is None:\nraise ValueError(\"Timer has not been stopped.\")\nreturn None\n</code></pre>"},{"location":"timer/#wraptimer.timer.Timer.time_microsec","title":"time_microsec  <code>property</code>","text":"<pre><code>time_microsec: float\n</code></pre> <p>Get number of microseconds taken from start() to stop().</p> <p>Returns:     <code>float</code>: microseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_millisec","title":"time_millisec  <code>property</code>","text":"<pre><code>time_millisec: float\n</code></pre> <p>Get number of milliseconds taken from start() to stop().</p> <p>Returns:     <code>float</code>: milliseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_nanosec","title":"time_nanosec  <code>property</code>","text":"<pre><code>time_nanosec: float\n</code></pre> <p>Get number of nanoseconds taken from start() to stop().</p> <p>Returns:     <code>float</code>: nanoseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_sec","title":"time_sec  <code>property</code>","text":"<pre><code>time_sec: float\n</code></pre> <p>Get number of seconds taken from start() to stop().</p> <p>Returns:     <code>float</code>: seconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.time_string","title":"time_string  <code>property</code>","text":"<pre><code>time_string: str\n</code></pre> <p>Get human readable duration taken from start() to stop().</p> <p>Returns:     <code>str</code>: human readable duration</p>"},{"location":"timer/#wraptimer.timer.Timer.time_units","title":"time_units  <code>property</code>","text":"<pre><code>time_units: dict\n</code></pre> <p>Get dictionary of time taken from start() to stop().</p> <p>Returns:     <code>float</code>: nanoseconds as a float</p>"},{"location":"timer/#wraptimer.timer.Timer.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Starts the timer .</p> Source code in <code>wraptimer/timer.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Starts the timer .\"\"\"\nif self._is_started:\nreturn\nif self.disable_garbage_collect:\ngc.disable()\nself._counter_start = self.__get_counter()\nself._is_started = True\n</code></pre>"},{"location":"timer/#wraptimer.timer.Timer.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stops the timer .</p> Source code in <code>wraptimer/timer.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stops the timer .\"\"\"\nself._counter_stop = self.__get_counter()\nif self.disable_garbage_collect:\ngc.enable()\nself._is_started = False\n</code></pre>"},{"location":"includes/abbreviations/","title":"Abbreviations","text":""}]}